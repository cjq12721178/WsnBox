package com.weisi.tool.wsnbox.activity;

import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.support.annotation.IdRes;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.text.TextUtils;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.TextView;

import com.cjq.lib.weisi.sensor.Filter;
import com.cjq.lib.weisi.sensor.MeasurementIdentifier;
import com.cjq.lib.weisi.sensor.Sensor;
import com.cjq.lib.weisi.sensor.SensorManager;
import com.cjq.lib.weisi.sensor.ValueContainer;
import com.cjq.tool.qbox.ui.adapter.AdapterDelegate;
import com.cjq.tool.qbox.ui.adapter.AutoGeneratedAdapterDelegateManager;
import com.cjq.tool.qbox.ui.adapter.RecyclerViewBaseAdapter;
import com.cjq.tool.qbox.ui.decoration.SpaceItemDecoration;
import com.cjq.tool.qbox.ui.dialog.ConfirmDialog;
import com.cjq.tool.qbox.ui.dialog.SortDialog;
import com.weisi.tool.wsnbox.R;
import com.weisi.tool.wsnbox.adapter.BaseSensorAdapterDelegate;
import com.weisi.tool.wsnbox.adapter.DataBrowseSensorAdapter;
import com.weisi.tool.wsnbox.adapter.MultipleMeasurementSensorAdapterDelegate;
import com.weisi.tool.wsnbox.adapter.SingleMeasurementSensorAdapterDelegate;
import com.weisi.tool.wsnbox.bean.filter.SensorWithHistoryValueFilter;
import com.weisi.tool.wsnbox.bean.filter.FilterCollection;
import com.weisi.tool.wsnbox.bean.filter.SensorUseForRealtimeFilter;
import com.weisi.tool.wsnbox.bean.filter.SearchFilter;
import com.weisi.tool.wsnbox.bean.sorter.SensorAddressSorter;
import com.weisi.tool.wsnbox.bean.sorter.SensorEarliestValueTimeSorter;
import com.weisi.tool.wsnbox.bean.sorter.SensorSorter;
import com.weisi.tool.wsnbox.bean.sorter.SensorNetInTimeSorter;
import com.weisi.tool.wsnbox.bean.filter.SensorSourceFilter;
import com.weisi.tool.wsnbox.fragment.SensorInformationFragment;
import com.weisi.tool.wsnbox.io.SensorDatabase;
import com.weisi.tool.wsnbox.service.DataPrepareService;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

public class DataBrowseActivity
        extends BaseActivity
        implements DataPrepareService.OnSensorNetInListener,
        DataPrepareService.OnSensorValueUpdateListener,
        RecyclerViewBaseAdapter.OnItemClickListener,
        View.OnClickListener,
        SortDialog.OnSortTypeChangedListener {

    private static final int FROM_BLE_ONLY = 1;
    private static final int FROM_UDP_ONLY = 2;
    private static final int FROM_BOTH = 3;

    private static final int SORTED_BY_ADDRESS = 1;
    private static final int SORTED_BY_TIME = 2;

    private static final int MSG_SENSOR_NET_IN_REAL_TIME = 1;
    private static final int MSG_SENSOR_VALUE_UPDATE = 2;
    private static final int MSG_SENSOR_NET_IN_HISTORY = 3;
    //private static final int MSG_SENSOR_VALUE_INSERT = 4;

    private static final String ARGUMENT_KEY_SELECTED_SENSOR_ADDRESS = "selected_sensor";
    private static final String ARGUMENT_KEY_SELECTED_SENSOR_INDEX = "selected_index";
    private static final String ARGUMENT_KEY_DATA_SOURCE = "data_source";
    private static final String ARGUMENT_KEY_SENSOR_SORT_TYPE = "sort_type";
    private static final String ARGUMENT_KEY_SENSOR_SOURCE = "sensor_source";

    private boolean mIsRealTime;
    private final List<Sensor> mSensors = new ArrayList<>();
    private Filter mDataSourceFilter;
    private SensorSourceFilter mSensorSourceFilter;
    private SearchFilter mSearchFilter;
    private SensorSorter mSensorSorter;// = new SensorNetInTimeSorter();
    private DataBrowseSensorAdapter mSensorAdapter;
    private SortDialog mSortDialog;
    private RecyclerView mRvSensors;
    private SensorInformationFragment mSensorInformationFragment;
    private boolean mTaskRunning;

    private final Handler mEventHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
                case MSG_SENSOR_NET_IN_REAL_TIME: {
                    if (mIsRealTime) {
                        addSensor((Sensor) msg.obj);
                    }
                } break;
                case MSG_SENSOR_VALUE_UPDATE: {
                    Sensor sensor = (Sensor) msg.obj;
                    int measurementValuePosition = msg.arg1;
                    if (!mIsRealTime) {
                        if (sensor.interpretAddResult(measurementValuePosition, mIsRealTime)
                                != ValueContainer.NEW_VALUE_ADDED) {
                            return;
                        }
                    }
                    int position = mSensorSorter.find(mSensors, sensor);
                    if (position >= 0) {
                        mSensorAdapter.notifySensorValueUpdate(position);
                        if (mSensorInformationFragment != null) {
                            mSensorInformationFragment.notifySensorDataChanged(sensor, measurementValuePosition);
                        }
                    }
                } break;
                case MSG_SENSOR_NET_IN_HISTORY: {
                    if (!mIsRealTime) {
                        addSensor((Sensor) msg.obj);
                    }
                } break;
                default:
                    break;
            }
        }
    };

    private void addSensor(Sensor sensor) {
        //根据设置有序添加
        int position = mSensorSorter.add(mSensors, sensor);
        if (position != -1) {
            mSensorAdapter.notifySensorNetIn(position);
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_data_browse);
        //以下三个方法的次序不能改变
        initializeView();
        confirmDataSource(savedInstanceState);
        initializeParameters(savedInstanceState);
    }

    private void initializeView() {
        findViewById(R.id.tv_sort).setOnClickListener(this);
        findViewById(R.id.tv_filter).setOnClickListener(this);
        findViewById(R.id.tv_search).setOnClickListener(this);

        //创建DataBrowseSensorAdapter
        AutoGeneratedAdapterDelegateManager delegateManager = new AutoGeneratedAdapterDelegateManager() {
            @Override
            protected AdapterDelegate onCreateAdapterDelegate(int viewType) {
                return new MultipleMeasurementSensorAdapterDelegate(viewType);
            }
        };
        delegateManager.addAdapterDelegate(new SingleMeasurementSensorAdapterDelegate());
        mSensorAdapter = new DataBrowseSensorAdapter(delegateManager, mSensors);
        mSensorAdapter.setOnItemClickListener(this);
    }

    private void confirmDataSource(Bundle savedInstanceState) {
        mIsRealTime = savedInstanceState != null
                ? savedInstanceState.getBoolean(ARGUMENT_KEY_DATA_SOURCE)
                : true;
        BaseSensorAdapterDelegate.setRealTime(mIsRealTime);
    }

    private void initializeParameters(Bundle savedInstanceState) {
        setDataSource();
        if (savedInstanceState != null) {
            setSensorSorter(savedInstanceState.getInt(ARGUMENT_KEY_SENSOR_SORT_TYPE));
            setSensorSource(savedInstanceState.getInt(ARGUMENT_KEY_SENSOR_SOURCE));
            mSensorInformationFragment = (SensorInformationFragment) getSupportFragmentManager()
                    .findFragmentByTag(SensorInformationFragment.TAG);
            if (mSensorInformationFragment != null) {
                mSensorInformationFragment.setSensor(getSavedSelectedSensor(savedInstanceState));
                mSensorInformationFragment.setRealTime(mIsRealTime);
            }
            mSensorAdapter.setSelectedIndex(savedInstanceState.getInt(ARGUMENT_KEY_SELECTED_SENSOR_INDEX));
        } else {
            setSensorSorter(SORTED_BY_TIME);
            setSensorSource(FROM_BOTH);
        }
    }

    private Sensor getSavedSelectedSensor(Bundle savedInstanceState) {
        int selectedAddress = savedInstanceState.getInt(ARGUMENT_KEY_SELECTED_SENSOR_ADDRESS);
        if (selectedAddress == -1) {
            return null;
        }
        return SensorManager.getSensor(selectedAddress, false);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.menu_data_browse, menu);
        setDataSourceLabel(menu.findItem(R.id.mi_data_source));
        return super.onCreateOptionsMenu(menu);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.mi_data_source:
                if (mSensors.size() > 0) {
                    mRvSensors.scrollToPosition(0);
                }
                mIsRealTime = !mIsRealTime;
                //CodeRunTimeCatcher.start();
                setDataSourceLabel(item);
                setSensorSorter(getSensorSortType());
                setDataSource();
                onDataSourceChanged();
                //ClosableLog.d(Tag.LOG_TAG_D_CODE_RUN_TIME, "real time to history spend time = " + CodeRunTimeCatcher.end());
                break;
        }
        return super.onOptionsItemSelected(item);
    }

    private void setDataSourceLabel(MenuItem item) {
        item.setTitle(getString(mIsRealTime
                ? R.string.real_time
                : R.string.history));
    }

    private void onDataSourceChanged() {
        BaseSensorAdapterDelegate.setRealTime(mIsRealTime);
        onSensorFilterChanged();
        DataPrepareService service = getDataPrepareService();
        if (mIsRealTime) {
            service.setOnSensorNetInListener(this);
            service.startSensorValueUpdater(this);
        } else {
            service.setOnSensorNetInListener(null);
            service.stopSensorValueUpdater();
            importSensorsWithHistoryValue();
        }
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putInt(ARGUMENT_KEY_SELECTED_SENSOR_INDEX, mSensorAdapter.getSelectedIndex());
        Sensor selectedSensor = mSensorInformationFragment != null
                ? mSensorInformationFragment.getSensor()
                : null;
        outState.putInt(ARGUMENT_KEY_SELECTED_SENSOR_ADDRESS,
                selectedSensor != null
                        ? selectedSensor.getRawAddress()
                        : -1);
        outState.putBoolean(ARGUMENT_KEY_DATA_SOURCE, mIsRealTime);
        outState.putInt(ARGUMENT_KEY_SENSOR_SORT_TYPE, getSensorSortType());
        outState.putInt(ARGUMENT_KEY_SENSOR_SOURCE, getSensorSource());
    }

    private int getSensorSortType() {
        if (mSensorSorter instanceof SensorNetInTimeSorter) {
            return SORTED_BY_TIME;
        } else if (mSensorSorter instanceof SensorEarliestValueTimeSorter) {
            return SORTED_BY_TIME;
        } else if (mSensorSorter instanceof SensorAddressSorter) {
            return SORTED_BY_ADDRESS;
        }
        return SORTED_BY_TIME;
    }

    private int getSensorSource() {
        if (mSensorSourceFilter == null) {
            return FROM_BOTH;
        }
        return mSensorSourceFilter.isSensorSourceBle()
                ? FROM_BLE_ONLY
                : FROM_UDP_ONLY;
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //防止内存泄漏
        mEventHandler.removeCallbacksAndMessages(null);
    }

    @Override
    protected void onServiceConnectionCreate(DataPrepareService service) {
        onSensorFilterChanged();
        if (mIsRealTime) {
            service.setOnSensorNetInListener(this);
        } else {
            importSensorsWithHistoryValue();
        }
        initSensorBrowseInterface();
    }

    private void importSensorsWithHistoryValue() {
        if (mTaskRunning) {
            return;
        }
        mTaskRunning = true;
        ImportSensorsWithEarliestValueTask task = new ImportSensorsWithEarliestValueTask();
        task.execute();
    }

    @Override
    protected void onServiceConnectionStart(DataPrepareService service) {
        if (mIsRealTime) {
            service.startSensorValueUpdater(this);
        }
    }

    @Override
    protected void onServiceConnectionStop(DataPrepareService service) {
        if (mIsRealTime) {
            service.stopSensorValueUpdater();
        }
    }

    @Override
    protected void onServiceConnectionDestroy(DataPrepareService service) {
        if (mIsRealTime) {
            service.setOnSensorNetInListener(null);
        }
    }

    private void onSensorFilterChanged() {
        synchronized (mSensors) {
            int oldSize = mSensors.size();
            mSensors.clear();
            SensorManager.getSensors(mSensors, getCurrentSensorFilter());
            mSensorSorter.sort(mSensors);
            mSensorAdapter.notifySensorFilterChanged(oldSize);
        }
    }

    private Filter getCurrentSensorFilter() {
        FilterCollection collection = new FilterCollection();
        collection.add(mDataSourceFilter);
        collection.add(mSensorSourceFilter);
        collection.add(mSearchFilter);
        return collection;
    }

    private void initSensorBrowseInterface() {
        mRvSensors = (RecyclerView) findViewById(R.id.rv_sensors);
        LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this);
        mRvSensors.setLayoutManager(linearLayoutManager);
        mRvSensors.addItemDecoration(new SpaceItemDecoration(getResources().getDimensionPixelSize(R.dimen.margin_small), true));
        mRvSensors.setAdapter(mSensorAdapter);
    }

//    public void setSensorSource(int source) {
//        if (source >= FROM_BLE_ONLY && source <= FROM_UDP_ONLY) {
//            if (mSensorSourceFilter == null) {
//                mSensorSourceFilter = new SensorSourceFilter();
//                mSensorSourceFilter.setSensorSource(FROM_BLE_ONLY == source);
//                onSensorFilterChanged();
//            } else {
//                boolean sensorSource = mSensorSourceFilter.isSensorSourceBle();
//                mSensorSourceFilter.setSensorSource(source == FROM_BLE_ONLY);
//                if (sensorSource != mSensorSourceFilter.isSensorSourceBle()) {
//                    onSensorFilterChanged();
//                }
//            }
//        } else {
//            if (mSensorSourceFilter != null) {
//                mSensorSourceFilter = null;
//                onSensorFilterChanged();
//            }
//        }
//    }

    public void setSearchCondition(String searchCondition) {
        if (TextUtils.isEmpty(searchCondition)) {
            if (mSearchFilter != null) {
                mSearchFilter = null;
                onSensorFilterChanged();
            }
        } else {
            if (mSearchFilter == null) {
                mSearchFilter = new SearchFilter();
                mSearchFilter.setSearchContents(searchCondition.split(" "));
            } else {
                String[] newSearchContents = searchCondition.split(" ");
                String[] oldSearchContents = mSearchFilter.getSearchContents();
                mSearchFilter.setSearchContents(newSearchContents);
                if (newSearchContents.length == oldSearchContents.length) {
                    int i = 0, size = newSearchContents.length;
                    for (;i < size;++i) {
                        if (!newSearchContents[i].equals(oldSearchContents[i])) {
                            break;
                        }
                    }
                    if (i == size) {
                        return;
                    }
                }
                onSensorFilterChanged();
            }
        }
    }

//    public void setSensorSorter(int sortType, boolean isDescend) {
//        SensorSorter newSorter;
//        switch (sortType) {
//            case SORTED_BY_ADDRESS:
//                newSorter =  new SensorAddressSorter();
//                break;
//            case SORTED_BY_TIME:
//            default:
//                newSorter = mIsRealTime
//                        ? new SensorNetInTimeSorter()
//                        : new SensorEarliestValueTimeSorter();
//                break;
//        }
//        if (setSensorSorter(newSorter)
//                || mSensorAdapter.setOrder(isDescend)) {
//            mSensorAdapter.notifySensorOrderChanged();
//        }
//    }
//
//    private boolean setSensorSorter(SensorSorter sensorSorter) {
//        if (sensorSorter.getClass() != mSensorSorter.getClass()) {
//            mSensorSorter = sensorSorter;
//            onSensorSorterOrOrderChanged();
//            return true;
//        }
//        return false;
//    }

    private boolean setDataSource() {
        Filter oldDataSourceFilter = mDataSourceFilter;
        if (mIsRealTime) {
            if (!(mDataSourceFilter instanceof SensorUseForRealtimeFilter)) {
                mDataSourceFilter = new SensorUseForRealtimeFilter();
            }
        } else {
            if (!(mDataSourceFilter instanceof SensorWithHistoryValueFilter)) {
                mDataSourceFilter = new SensorWithHistoryValueFilter();
            }
        }
        return oldDataSourceFilter != mDataSourceFilter;
    }

    private boolean setSensorSorter(int sortType) {
        SensorSorter oldSorter = mSensorSorter;
        switch (sortType) {
            case SORTED_BY_ADDRESS:
                if (!(mSensorSorter instanceof SensorAddressSorter)) {
                    mSensorSorter = new SensorAddressSorter();
                }
                break;
            case SORTED_BY_TIME:
            default:
                if (mIsRealTime) {
                    if (!(mSensorSorter instanceof SensorNetInTimeSorter)) {
                        mSensorSorter = new SensorNetInTimeSorter();
                    }
                } else {
                    if (!(mSensorSorter instanceof SensorEarliestValueTimeSorter)) {
                        mSensorSorter = new SensorEarliestValueTimeSorter();
                    }
                }
                break;
        }
        return oldSorter != mSensorSorter;
    }

    private void changeSensorSorterAndOrder(int sortType, boolean isDescend) {
        if (setSensorSorter(sortType) || mSensorAdapter.setOrder(isDescend)) {
            onSensorSorterOrOrderChanged();
        }
    }

    private void onSensorSorterOrOrderChanged() {
        synchronized (mSensors) {
            mSensorSorter.sort(mSensors);
        }
    }

    private boolean setSensorSource(int source) {
        if (source >= FROM_BLE_ONLY && source <= FROM_UDP_ONLY) {
            if (mSensorSourceFilter == null) {
                mSensorSourceFilter = new SensorSourceFilter();
                mSensorSourceFilter.setSensorSource(FROM_BLE_ONLY == source);
                return true;
            } else {
                boolean sensorSource = mSensorSourceFilter.isSensorSourceBle();
                mSensorSourceFilter.setSensorSource(source == FROM_BLE_ONLY);
                if (sensorSource != mSensorSourceFilter.isSensorSourceBle()) {
                    return true;
                }
            }
        } else {
            if (mSensorSourceFilter != null) {
                mSensorSourceFilter = null;
                return true;
            }
        }
        return false;
    }

    private void changeSensorSource(int source) {
        if (setSensorSource(source)) {
            onSensorFilterChanged();
        }
    }

    @Override
    public void onSensorNetIn(Sensor sensor) {
        if (mSensorSourceFilter != null && !mSensorSourceFilter.isMatch(sensor)) {
            return;
        }

        if (mSearchFilter != null && !mSearchFilter.isMatch(sensor)) {
            return;
        }

        notifyAdapterSensorNetIn(sensor, true);
    }

    private void notifyAdapterSensorNetIn(Sensor sensor, boolean isRealTime) {
        Message message = Message.obtain();
        message.what = isRealTime
                ? MSG_SENSOR_NET_IN_REAL_TIME
                : MSG_SENSOR_NET_IN_HISTORY;
        message.obj = sensor;
        mEventHandler.sendMessage(message);
    }

    @Override
    public void onSensorValueUpdate(Sensor sensor, int valuePosition) {
        notifyAdapterSensorValueUpdate(sensor, valuePosition);
    }

    private void notifyAdapterSensorValueUpdate(Sensor sensor, int valuePosition) {
        Message message = Message.obtain();
        message.what = MSG_SENSOR_VALUE_UPDATE;
        message.obj = sensor;
        message.arg1 = valuePosition;
        mEventHandler.sendMessage(message);
    }

    @Override
    public void onItemClick(View item, int position) {
        Sensor sensor = mSensorAdapter.getItemByPosition(position);
        if (mSensorInformationFragment == null) {
            mSensorInformationFragment = new SensorInformationFragment();
        }
        mSensorInformationFragment.show(getSupportFragmentManager(),
                sensor,
                mIsRealTime);
//        if (!mIsRealTime) {
//            sensor.setIntraday(System.currentTimeMillis());
//            ImportSensorHistoryInfoTask task = new ImportSensorHistoryInfoTask();
//            task.execute(sensor, System.currentTimeMillis());
//        }
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.tv_sensor_name_address:
                MultipleMeasurementSensorAdapterDelegate.setShowSensorNameOrAddress(setListHeadSensorNameOrAddress((TextView) v));
                //mSensorAdapter.notifyDataSetChanged();
                //mSensorAdapter.notifyItemRangeChanged(mLinearLayoutManager.findFirstVisibleItemPosition(),
                //        mLinearLayoutManager.findLastVisibleItemPosition());
                mSensorAdapter.notifySensorLabelChanged();
                break;
            case R.id.tv_measurement_name_type:
                MultipleMeasurementSensorAdapterDelegate.setShowMeasurementNameOrType(setListHeadMeasurementNameOrType((TextView) v));
                //mSensorAdapter.notifyDataSetChanged();
                //mSensorAdapter.notifyItemRangeChanged(mLinearLayoutManager.findFirstVisibleItemPosition(),
                //        mLinearLayoutManager.findLastVisibleItemPosition());
                mSensorAdapter.notifyMeasurementLabelChanged();
                break;
            case R.id.tv_sort:
                if (mSortDialog == null) {
                    mSortDialog = new SortDialog();
                    mSortDialog.addSortType(R.id.rb_address, R.string.address, this)
                            .addSortType(R.id.rb_time, R.string.timestamp, this)
                            .setDefaultSelectedId(R.id.rb_time);
                }
                mSortDialog.show(getSupportFragmentManager(), "sort_dialog");
                break;
        }
    }

    private boolean setListHeadSensorNameOrAddress(TextView tvSensorNameAddress) {
        String sensorNameLabel = getString(R.string.sensor_name);
        if (sensorNameLabel.equals(tvSensorNameAddress.getText())) {
            tvSensorNameAddress.setText(getString(R.string.sensor_address));
            return false;
        } else {
            tvSensorNameAddress.setText(sensorNameLabel);
            return true;
        }
    }

    private boolean setListHeadMeasurementNameOrType(TextView tvMeasurementNameType) {
        String measurementNameLabel = getString(R.string.measurement_name);
        if (measurementNameLabel.equals(tvMeasurementNameType.getText())) {
            tvMeasurementNameType.setText(getString(R.string.measurement_type));
            return false;
        } else {
            tvMeasurementNameType.setText(measurementNameLabel);
            return true;
        }
    }

    @Override
    public void onSortTypeChanged(@IdRes int checkedId, boolean isAscending) {
        switch (checkedId) {
            case R.id.rb_address:
                changeSensorSorterAndOrder(SORTED_BY_ADDRESS, !isAscending);
                break;
            case R.id.rb_time:
                changeSensorSorterAndOrder(SORTED_BY_TIME, !isAscending);
                break;
            default:
                break;
        }
    }

    private class ImportSensorsWithEarliestValueTask
            extends AsyncTask<Void, Void, Boolean>
            implements SensorDatabase.SensorHistoryInfoReceiver {

        private Sensor mTmpSensor;

        @Override
        protected Boolean doInBackground(Void... params) {
            int actualCount = SensorDatabase.getSensorWithHistoryValueCount();
            if (actualCount == -1) {
                return false;
            }
            if (actualCount == 0 ||
                    actualCount == SensorManager.getSensorWithHistoryValuesCount()) {
                return true;
            }
            return SensorDatabase.importSensorEarliestValue(this);
        }

        @Override
        protected void onPostExecute(Boolean result) {
            mTaskRunning = false;
            if (!result) {
                ConfirmDialog dialog = new ConfirmDialog();
                dialog.show(getSupportFragmentManager(),
                        "import_sensor_earliest_value_failed",
                        getString(R.string.import_sensor_earliest_value_failed),
                        false);
            }
        }

        @Override
        public void onSensorDataReceived(int address, long timestamp, float batteryVoltage) {
            Sensor sensor = SensorManager.getSensor(address, true);
            if (!sensor.hasHistoryValue()) {
                sensor.addHistoryValue(timestamp, batteryVoltage);
                if (!mIsRealTime) {
                    notifyAdapterSensorNetIn(sensor, false);
                }
            }
        }

        @Override
        public void onMeasurementDataReceived(long measurementValueId, long timestamp, double rawValue) {
            int address = MeasurementIdentifier.getAddress(measurementValueId);
            if (mTmpSensor == null || mTmpSensor.getRawAddress() != address) {
                mTmpSensor = SensorManager.getSensor(address, false);
            }
            notifyAdapterSensorValueUpdate(mTmpSensor,
                    mTmpSensor.addHistoryValue(measurementValueId,
                            timestamp, rawValue));
        }
    }

//    private class ImportSensorHistoryInfoTask
//            extends AsyncTask<Object, Object, Boolean>
//            implements SensorDatabase.SensorHistoryInfoReceiver {
//
//        private static final int TASK_SENSOR_DATA_RECEIVED = 1;
//        private static final int TASK_MEASUREMENT_DATA_RECEIVED = 2;
//
//        private Sensor mSensor;
//
//        @Override
//        protected Boolean doInBackground(Object... params) {
//            if (params == null) {
//                return false;
//            }
//            if (params.length < 1) {
//                return false;
//            }
//            if (!(params[0] instanceof Sensor)) {
//                return false;
//            }
//            mSensor = (Sensor) params[0];
//            if (mSensor.hasHistoryValue()) {
//                return true;
//            }
//            Calendar calendar = Calendar.getInstance();
//            calendar.set(Calendar.HOUR, 0);
//            calendar.set(Calendar.MINUTE, 0);
//            calendar.set(Calendar.SECOND, 0);
//            calendar.set(Calendar.MILLISECOND, 0);
//            long today = calendar.getTimeInMillis();
//            calendar.add(Calendar.DAY_OF_MONTH, 1);
//            long tomorrow = calendar.getTimeInMillis();
//            return SensorDatabase.importSensorHistoryValues(
//                    mSensor.getRawAddress(),
//                    today,
//                    tomorrow,
//                    0,
//                    this
//            );
//        }
//
//        @Override
//        protected void onProgressUpdate(Object... values) {
//            switch ((int) values[0]) {
//                case TASK_SENSOR_DATA_RECEIVED:
//                    mSensorInformationFragment.notifySensorDataChanged(
//                            mSensor,
//                            mSensor.addHistoryValue((long) values[1],
//                                    (float) values[2]));
//                    break;
//                case TASK_MEASUREMENT_DATA_RECEIVED:
//                    mSensorInformationFragment.notifyMeasurementDataChanged(
//                            mSensor,
//                            mSensor.addHistoryValue((long) values[1],
//                                    (long) values[2],
//                                    (double) values[3]),
//                            (long) values[2]
//                    );
//            }
//        }
//
//        @Override
//        protected void onPostExecute(Boolean result) {
//            if (!result) {
//                ConfirmDialog dialog = new ConfirmDialog();
//                dialog.show(getSupportFragmentManager(),
//                        "import_sensor_history_value_failed",
//                        getString(R.string.import_sensor_history_value_failed),
//                        false);
//            }
//        }
//
//        @Override
//        public void onSensorDataReceived(int address, long timestamp, float batteryVoltage) {
//            publishProgress(TASK_SENSOR_DATA_RECEIVED, timestamp, batteryVoltage);
//        }
//
//        @Override
//        public void onMeasurementDataReceived(long measurementValueId, long timestamp, double rawValue) {
//            publishProgress(TASK_MEASUREMENT_DATA_RECEIVED, measurementValueId, timestamp, rawValue);
//        }
//    }
}
