package com.weisi.tool.wsnbox.fragment

import android.os.Bundle
import android.support.v7.widget.LinearLayoutManager
import android.support.v7.widget.RecyclerView
import android.text.TextUtils
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import com.cjq.lib.weisi.data.Filter
import com.cjq.lib.weisi.data.Storage
import com.cjq.lib.weisi.iot.LogicalSensor
import com.cjq.lib.weisi.iot.PhysicalSensor
import com.cjq.lib.weisi.iot.SensorManager
import com.cjq.lib.weisi.iot.ValueContainer
import com.cjq.tool.qbox.ui.adapter.AdapterDelegate
import com.cjq.tool.qbox.ui.adapter.AutoGeneratedAdapterDelegateManager
import com.cjq.tool.qbox.ui.decoration.SpaceItemDecoration
import com.cjq.tool.qbox.ui.dialog.ConfirmDialog
import com.cjq.tool.qbox.ui.dialog.FilterDialog
import com.cjq.tool.qbox.ui.dialog.SortDialog
import com.cjq.tool.qbox.ui.gesture.SimpleRecyclerViewItemTouchListener
import com.weisi.tool.wsnbox.R
import com.weisi.tool.wsnbox.adapter.BaseSensorAdapterDelegate
import com.weisi.tool.wsnbox.adapter.BaseSensorAdapterDelegate.*
import com.weisi.tool.wsnbox.adapter.DataBrowsePhysicalSensorAdapter
import com.weisi.tool.wsnbox.adapter.MultipleMeasurementSensorAdapterDelegate
import com.weisi.tool.wsnbox.adapter.SingleMeasurementSensorAdapterDelegate
import com.weisi.tool.wsnbox.bean.filter.*
import com.weisi.tool.wsnbox.bean.sorter.SensorAddressSorter
import com.weisi.tool.wsnbox.bean.sorter.SensorEarliestValueTimeSorter
import com.weisi.tool.wsnbox.bean.sorter.SensorNameSorter
import com.weisi.tool.wsnbox.bean.sorter.SensorNetInTimeSorter
import com.weisi.tool.wsnbox.bean.warner.processor.CommonWarnProcessor
import com.weisi.tool.wsnbox.dialog.PhysicalSensorInfoDialog
import com.weisi.tool.wsnbox.dialog.SensorInfoDialog
import com.weisi.tool.wsnbox.processor.accessor.SensorHistoryDataAccessor
import com.weisi.tool.wsnbox.service.DataPrepareService

/**
 * Created by CJQ on 2018/5/29.
 */
class PhysicalSensorFragment : DataBrowseFragment<PhysicalSensor, DataBrowsePhysicalSensorAdapter>(),
        View.OnClickListener,
        SensorHistoryDataAccessor.OnMissionFinishedListener {

    private lateinit var rvSensors: RecyclerView
    private var physicalSensorInfoDialog: PhysicalSensorInfoDialog? = null

    override fun onCreateStorage(): Storage<PhysicalSensor> {
        val s = Storage<PhysicalSensor>() { elements, filters ->
            SensorManager.getSensors(elements, filters, PhysicalSensor::class.java)
        }
        s.addFilter(FILTER_ID_DATA_SOURCE, SensorUseForRealTimeFilter())
        s.setSorter(SensorNetInTimeSorter(), false)
        return s
    }

    override fun onRecoverInformationDialog(savedInstanceState: Bundle?) {
        savedInstanceState ?: return
        physicalSensorInfoDialog = childFragmentManager
                .findFragmentByTag(SensorInfoDialog.TAG) as PhysicalSensorInfoDialog?
                ?: return
        //physicalSensorInfoDialog?.setRealTime(isRealTime())
        //physicalSensorInfoDialog?.sensor = getSavedSelectedSensor(savedInstanceState) ?: return
        //getBaseActivity().dataPrepareService.dataTransferStation.payAttentionToSensor(physicalSensorInfoDialog!!.sensor)
    }

    private fun getSavedSelectedSensor(savedInstanceState: Bundle): PhysicalSensor? {
        val selectedAddress = savedInstanceState.getInt(ARGUMENT_KEY_SELECTED_SENSOR_ADDRESS)
        return if (selectedAddress == -1) {
            null
        } else SensorManager.getPhysicalSensor(selectedAddress, false)
    }

    override fun onInitView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        return inflater.inflate(R.layout.fragment_physical_sensor, null)
    }

    override fun onInitAdapter(view: View, storage: Storage<PhysicalSensor>): DataBrowsePhysicalSensorAdapter {
        //绑定事件
        view.findViewById<TextView>(R.id.tv_sensor_name_address).setOnClickListener(this)
        view.findViewById<TextView>(R.id.tv_measurement_name_type).setOnClickListener(this)

        //初始化RecycleView
        rvSensors = view.findViewById<RecyclerView>(R.id.rv_sensors)
        rvSensors.layoutManager = LinearLayoutManager(context)
        rvSensors.addItemDecoration(SpaceItemDecoration(resources.getDimensionPixelSize(R.dimen.margin_small), true))
        rvSensors.addOnItemTouchListener(object : SimpleRecyclerViewItemTouchListener(rvSensors) {
            override fun onItemClick(v: View, position: Int) {
                val sensor = adapter.getItemByPosition(position)
                if (physicalSensorInfoDialog == null) {
                    physicalSensorInfoDialog = PhysicalSensorInfoDialog()
                }
                getBaseActivity().dataPrepareService.dataTransferStation.payAttentionToSensor(sensor)
                physicalSensorInfoDialog!!.show(childFragmentManager,
                        sensor,
                        isRealTime())
            }
        })

        //BaseSensorAdapterDelegate.setWarnProcessor(getBaseActivity().warnProcessor)

        //创建DataBrowseSensorAdapter
        val delegateManager = object : AutoGeneratedAdapterDelegateManager<PhysicalSensor>() {
            override fun onCreateAdapterDelegate(viewType: Int): AdapterDelegate<PhysicalSensor> {
                return MultipleMeasurementSensorAdapterDelegate(viewType)
            }
        }
        delegateManager.addAdapterDelegate(SingleMeasurementSensorAdapterDelegate())
        val sensorAdapter = DataBrowsePhysicalSensorAdapter(delegateManager, storage)
        rvSensors.adapter = sensorAdapter
        return sensorAdapter
    }

    override fun onClick(v: View?) {
        when (v?.id) {
            R.id.tv_sensor_name_address -> {
                BaseSensorAdapterDelegate.setShowSensorNameOrAddress(setListHeadSensorNameOrAddress(v as TextView))
                adapter.notifyItemRangeChanged(0, adapter.getItemCount(),
                        UPDATE_TYPE_SENSOR_LABEL_CHANGED)
            }
            R.id.tv_measurement_name_type -> {
                BaseSensorAdapterDelegate.setShowMeasurementNameOrType(setListHeadMeasurementNameOrType(v as TextView))
                adapter.notifyItemRangeChanged(0, adapter.getItemCount(),
                        UPDATE_TYPE_MEASUREMENT_LABEL_CHANGED)
            }
        }
    }

    private fun setListHeadSensorNameOrAddress(tvSensorNameAddress: TextView): Boolean {
        val sensorNameLabel = getString(R.string.sensor_name)
        if (sensorNameLabel == tvSensorNameAddress.text) {
            tvSensorNameAddress.text = getString(R.string.sensor_address)
            return false
        } else {
            tvSensorNameAddress.text = sensorNameLabel
            return true
        }
    }

    private fun setListHeadMeasurementNameOrType(tvMeasurementNameType: TextView): Boolean {
        val measurementNameLabel = getString(R.string.measurement_name)
        if (measurementNameLabel == tvMeasurementNameType.text) {
            tvMeasurementNameType.text = getString(R.string.measurement_type)
            return false
        } else {
            tvMeasurementNameType.text = measurementNameLabel
            return true
        }
    }

    override fun onServiceConnectionStart(service: DataPrepareService) {
        if (isRealTime()) {
            service.dataTransferStation.enableDetectPhysicalSensorValueUpdate = true
        }
    }

    override fun onServiceConnectionStop(service: DataPrepareService) {
        if (isRealTime()) {
            service.dataTransferStation.enableDetectPhysicalSensorValueUpdate = false
        }
    }

    override fun onServiceConnectionDestroy(service: DataPrepareService) {
        if (isRealTime()) {
            service.dataTransferStation.enableDetectPhysicalSensorNetIn = false
        }
        super.onServiceConnectionDestroy(service)
    }

    override fun onDataSourceChange(realTime: Boolean) {
        super.onDataSourceChange(realTime)
        val service = getBaseActivity().dataPrepareService ?: return
        BaseSensorAdapterDelegate.setRealTime(realTime)
        val transfer = service.dataTransferStation
        transfer.enableDetectLogicalSensorNetIn = false
        transfer.enableDetectLogicalSensorValueUpdate = false
        if (realTime) {
            storage.addFilter(FILTER_ID_DATA_SOURCE, SensorUseForRealTimeFilter<PhysicalSensor>())
            if (storage.sorter is SensorEarliestValueTimeSorter) {
                storage.setSorter(SensorNetInTimeSorter(), storage.isDescend)
            }
            transfer.enableDetectPhysicalSensorNetIn = true
            transfer.enableDetectPhysicalSensorValueUpdate = true
            transfer.enableDetectPhysicalSensorHistoryValueReceive = false
            transfer.enableDetectLogicalSensorHistoryValueReceive = false
        } else {
            storage.addFilter(FILTER_ID_DATA_SOURCE, SensorWithHistoryValueFilter<PhysicalSensor>())
            if (storage.sorter is SensorNetInTimeSorter) {
                storage.setSorter(SensorEarliestValueTimeSorter(), storage.isDescend)
            }
            transfer.enableDetectPhysicalSensorNetIn = false
            transfer.enableDetectPhysicalSensorValueUpdate = false
            transfer.enableDetectPhysicalSensorHistoryValueReceive = true
            transfer.enableDetectLogicalSensorHistoryValueReceive = true
            getBaseActivity().dataPrepareService.sensorHistoryDataAccessor.importSensorsWithEarliestValue(this, true)
        }
        storage.refresh(null, this)
    }

    override fun onMissionFinished(result: Boolean) {
        if (!result) {
            val dialog = ConfirmDialog()
            dialog.setTitle(R.string.import_sensor_earliest_value_failed)
            dialog.setDrawCancelButton(false)
            dialog.show(childFragmentManager,
                    "import_sensor_earliest_value_failed")
        }
        getBaseActivity().dataPrepareService.dataTransferStation.enableDetectLogicalSensorHistoryValueReceive = false
    }

//    override fun onSaveInstanceState(outState: Bundle) {
//        super.onSaveInstanceState(outState)
//        outState.putInt(ARGUMENT_KEY_SELECTED_SENSOR_INDEX, adapter.selectedIndex)
//        outState.putInt(ARGUMENT_KEY_SELECTED_SENSOR_ADDRESS,
//                physicalSensorInfoDialog?.sensor?.rawAddress ?: -1)
//    }

    override fun onDestroy() {
        //释放配置资源
        BaseSensorAdapterDelegate.setWarnProcessor(null)
        //SensorInfoAdapter.warnProcessor = null
        super.onDestroy()
    }

    override fun onPhysicalSensorNetIn(sensor: PhysicalSensor) {
        addSensor(sensor)
    }

    private fun addSensor(sensor: PhysicalSensor) {
        //根据设置有序添加
        val position = storage.add(sensor)
        if (position != -1) {
            adapter.notifyItemInserted(position)
        }
    }

    override fun onPhysicalSensorDynamicValueUpdate(sensor: PhysicalSensor, logicalPosition: Int) {
        //notifySensorValueUpdate(sensor, logicalPosition)
        val position = storage.find(sensor)
        if (position >= 0) {
            adapter.notifyItemChanged(position, UPDATE_TYPE_VALUE_CHANGED)
            physicalSensorInfoDialog?.notifyPhysicalSensorRealTimeValueChanged(sensor, logicalPosition)
        }
    }

//    private fun notifySensorValueUpdate(sensor: PhysicalSensor, valuePosition: Int) {
//        val position = storage.find(sensor)
//        if (position >= 0) {
//            adapter.notifyItemChanged(position, UPDATE_TYPE_VALUE_CHANGED)
//            physicalSensorInfoDialog?.notifySensorValueChanged(sensor, valuePosition)
//        }
//    }

    override fun onPhysicalSensorHistoryValueUpdate(sensor: PhysicalSensor, logicalPosition: Int) {
        if (logicalPosition == 0) {
            if (sensor.historyValueContainer
                            .interpretAddResult(logicalPosition) == ValueContainer.NEW_VALUE_ADDED) {
                addSensor(sensor)
            }
        } else {
            physicalSensorInfoDialog?.notifyPhysicalSensorHistoryValueChanged(sensor, logicalPosition)
        }
    }

    override fun onLogicalSensorHistoryValueUpdate(sensor: LogicalSensor, logicalPosition: Int) {
        if (logicalPosition == 0) {
            val physicalSensor = sensor.physicalSensor
            if (physicalSensor.hasHistoryValue()) {
                val position = storage.find(physicalSensor)
                if (position >= 0) {
                    adapter.notifyItemChanged(position, UPDATE_TYPE_VALUE_CHANGED)
                }
            }
        }
        physicalSensorInfoDialog?.notifyLogicalSensorHistoryValueChanged(sensor, logicalPosition)
//        val value = sensor.getValueByContainerAddMethodReturnValue(sensor.historyValueContainer, logicalPosition)
//        if (value != null) {
//            val physicalSensor = sensor.physicalSensor
//            val position = physicalSensor.historyValueContainer.findValuePosition(logicalPosition, value.timestamp)
//            if (position >= 0) {
//                if (logicalPosition == 0) {
//                    notifySensorValueUpdate(physicalSensor, position)
//                }
//                physicalSensorInfoDialog?.notifySensorValueChanged(physicalSensor, position)
//            }
//        }
    }

    override fun onImportWarnProcessor(processor: CommonWarnProcessor<View>) {
        super.onImportWarnProcessor(processor)
        BaseSensorAdapterDelegate.setWarnProcessor(processor)
        //SensorInfoAdapter.warnProcessor = processor
        adapter.notifyItemRangeChanged(0, adapter.itemCount, UPDATE_TYPE_VALUE_CHANGED)
        physicalSensorInfoDialog?.notifyWarnProcessorLoaded()
    }

    override fun onInitSortDialog(dialog: SortDialog): SortDialog {
        return dialog
                .addSortType(R.id.rb_address, R.string.address, context)
                .addSortType(R.id.rb_time, R.string.timestamp, context)
                .addSortType(R.id.rb_name, R.string.name, context)
                .setDefaultSelectedId(when (storage.sorter) {
                    is SensorAddressSorter -> R.id.rb_address
                    is SensorNameSorter -> R.id.rb_name
                    else -> R.id.rb_time
                })
    }

    override fun onInitFilterDialog(dialog: FilterDialog): FilterDialog {
        return dialog
                .addFilterType(getString(R.string.sensor_protocol),
                        resources.getStringArray(R.array.usb_protocols),
                        when (storage.getFilter(FILTER_ID_SENSOR_PROTOCOL)) {
                            is BleProtocolFilter -> booleanArrayOf(false, true)
                            is EsbProtocolFilter -> booleanArrayOf(true, false)
                            else -> booleanArrayOf(false, false)
                        })
                .addFilterType(getString(R.string.sensor_type),
                        PhysicalSensorTypeFilter.sensorTypeNames,
                        getSensorTypeFilterStates(storage.getFilter(FILTER_ID_SENSOR_TYPE)))
    }

    private fun getSensorTypeFilterStates(filter: Filter<PhysicalSensor>?): BooleanArray? {
        if (filter !is PhysicalSensorTypeFilter || filter.selectedSensorTypeNos.isEmpty()) {
            return null
        }
        val result = BooleanArray(PhysicalSensorTypeFilter.sensorTypeNames.size)
        for (selectedSensorTypeNo in filter.selectedSensorTypeNos) {
            result[selectedSensorTypeNo] = true
        }
        return result
    }

    override fun onSortTypeChanged(checkedId: Int, isAscending: Boolean) {
        storage.setSorter(when (checkedId) {
            R.id.rb_address -> SensorAddressSorter()
            R.id.rb_name -> SensorNameSorter()
            R.id.rb_time -> if (isRealTime()) {
                SensorNetInTimeSorter()
            } else {
                SensorEarliestValueTimeSorter()
            }
            else -> SensorNetInTimeSorter()
        }, !isAscending, this)
    }

    override fun onFilterChange(dialog: FilterDialog?, hasFilters: BooleanArray?, checkedFilterEntryValues: Array<out MutableList<Int>>?) {
        //筛选协议
        if (hasFilters!![0]) {
            storage.addFilter(FILTER_ID_SENSOR_PROTOCOL,
                    if (checkedFilterEntryValues!![0][0] == 0) {
                        EsbProtocolFilter()
                    } else {
                        BleProtocolFilter()
                    })
        }
        //筛选类型
        if (hasFilters[1]) {
            storage.addFilter(FILTER_ID_SENSOR_TYPE, PhysicalSensorTypeFilter(checkedFilterEntryValues!![1]))
        }
        storage.reFiltrate(this)
    }

    override fun onSearch(target: String?) {
        if (TextUtils.isEmpty(target)) {
            storage.removeFilter(FILTER_ID_SENSOR_INFO)
        } else {
            storage.addFilter(FILTER_ID_SENSOR_INFO, PhysicalSensorInfoFilter(target!!))
        }
        storage.reFiltrate(this)
    }
}